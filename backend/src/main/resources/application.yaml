spring:
  application:
    name: backend

  # These values are variables for Heroku deployment for the backend's database. Consult deployment documentation on how to use them during deployment.
  # If you wish to use a different database during development, change the values to your db's appropriate credentials (see below).
  # Leaving them as-is and running the application locally will use compose.yaml from the project root to start the db with docker.
  #datasource:
  #username: ${SPRING_DATASOURCE_USERNAME}
  #password: ${SPRING_DATASOURCE_PASSWORD}
  #url: ${SPRING_DATASOURCE_URL}

  # Like this:
  datasource:
    url: ${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5433/fisma_db}
    username: ${SPRING_DATASOURCE_USERNAME:myuser}
    password: ${SPRING_DATASOURCE_PASSWORD:secret}

  # Database initialization mode (always, never) and data locations are set in Heroku config vars
  # This ensures we can dynamically control database seeding in different environments
  # Default values are set for local development
  sql:
    init:
      mode: ${DATABASE_INIT_MODE:always} # always set for dev environment
      data-locations: classpath:${DATABASE_SEED_FILE:database-seed-dev.sql}

jwt:
  private.key: classpath:./jwt-keys/app.key
  public.key: classpath:./jwt-keys/app.pub

# Debug Configuration
api:
  debug: ${API_DEBUG:never} # Use this inside code to toggle debug features if needed

server:
  error:
    include-message: ${API_DEBUG:never}
    include-stacktrace: ${API_DEBUG:never}
    include-exception: false
    include-binding-errors: ${API_DEBUG:never}

logging:
  level:
    org.springframework.security: ${API_DEBUG_LEVEL:info}
    org.springframework.security.web: ${API_DEBUG_LEVEL:info}
    org.springframework.security.oauth2: ${API_DEBUG_LEVEL:info}

management:
  endpoints:
    web:
      exposure:
        include: health, info

docker:
  compose:
    enabled: ${SPRING_DOCKER_COMPOSE_ENABLED:false}
